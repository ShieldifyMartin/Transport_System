package org.example.service;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.IOException;
import java.math.BigDecimal;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.LocalDate;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;
import org.example.dao.CompanyDAO;
import org.example.dao.TransportOrderDAO;
import org.example.dao.VehicleDAO;
import org.example.entity.Company;
import org.example.entity.TransportOrder;
import org.example.entity.enums.TransportType;

public class TransportOrderService {
    // Standart getter functions

    // Get Transport Order by ID
    public TransportOrder getTransportOrderById(long id) {
        return TransportOrderDAO.getTransportOrderById(id);
    }

    // Get list of active (non-deleted) transport orders
    public List<TransportOrder> getActiveTransportOrders() {
        return TransportOrderDAO.getTransportOrders();
    }

    // Report related getter functions

    // Get total number of transport orders
    public long getTotalTransportOrders() {
        return getActiveTransportOrders().size();
    }

    // Get total revenue from transport orders
    public BigDecimal getTotalTransportRevenue() {
        return getActiveTransportOrders().stream()
            .map(TransportOrder::getAmount)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    // Get a list of drivers and the number of transports they've completed
    public Map<String, Long> getTransportCountByDriver() {
        return getActiveTransportOrders().stream()
            .collect(Collectors.groupingBy(
                order -> order.getDriver().getName(),
                Collectors.counting()
            ));
    }

    // Get company revenue for a specific period
    public BigDecimal getCompanyRevenueForPeriod(LocalDate startDate, LocalDate endDate) {
        return getActiveTransportOrders().stream()
            .filter(order -> !order.getDepartureDate().isBefore(startDate) &&
                            !order.getDepartureDate().isAfter(endDate))
            .map(TransportOrder::getAmount)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    // Get revenue generated by each driver
    public Map<String, BigDecimal> getRevenueByDriver() {
        return getActiveTransportOrders().stream()
            .collect(Collectors.groupingBy(
                order -> order.getDriver().getName(),
                Collectors.mapping(
                    TransportOrder::getAmount,
                    Collectors.reducing(BigDecimal.ZERO, BigDecimal::add)
                )
            ));
    }

    // Sorting functions

    // Sorting by departure date (ascending)
    public List<TransportOrder> sortTransportOrdersByDepartureDate() {
        return getActiveTransportOrders().stream()
            .sorted(Comparator.comparing(TransportOrder::getDepartureDate))
            .collect(Collectors.toList());
    }

    // Sorting by transport amount (descending)
    public List<TransportOrder> sortTransportOrdersByAmountDesc() {
        return getActiveTransportOrders().stream()
            .sorted(Comparator.comparing(TransportOrder::getAmount).reversed())
            .collect(Collectors.toList());
    }

    // Filter functions

    public List<TransportOrder> filterTransportOrdersByType(TransportType transportType) {
        return getActiveTransportOrders().stream()
            .filter(order -> order.getTransportType() == transportType)
            .collect(Collectors.toList());
    }

    // Filter transport orders by departure location
    public List<TransportOrder> filterTransportOrdersByDepartureLocation(String departureLocation) {
        if (departureLocation == null || departureLocation.isBlank()) {
            throw new IllegalArgumentException("Departure location cannot be null or blank");
        }

        return getActiveTransportOrders().stream()
            .filter(order -> departureLocation.equalsIgnoreCase(order.getDepartureLocation()))
            .collect(Collectors.toList());
    }

    // Filter transport orders by destination location
    public List<TransportOrder> filterTransportOrdersByDestinationLocation(String destinationLocation) {
        if (destinationLocation == null || destinationLocation.isBlank()) {
            throw new IllegalArgumentException("Destination location cannot be null or blank");
        }

        return getActiveTransportOrders().stream()
            .filter(order -> destinationLocation.equalsIgnoreCase(order.getDestinationLocation()))
            .collect(Collectors.toList());
    }

    // Advanced filter: Filter transport orders by multiple criteria
    public List<TransportOrder> filterTransportOrdersAdvanced(
            LocalDate departureDateFrom, LocalDate departureDateTo,
            BigDecimal minAmount, BigDecimal maxAmount,
            Boolean isPaid) {
        return getActiveTransportOrders().stream()
            .filter(order -> (departureDateFrom == null || !order.getDepartureDate().isBefore(departureDateFrom))
                && (departureDateTo == null || !order.getDepartureDate().isAfter(departureDateTo))
                && (minAmount == null || order.getAmount().compareTo(minAmount) >= 0)
                && (maxAmount == null || order.getAmount().compareTo(maxAmount) <= 0)
                && (isPaid == null || order.getIsPaid().equals(isPaid)))
            .collect(Collectors.toList());
    }

    // Save new transport order
    public void saveTransportOrder(TransportOrder transportOrder) {
        // Validate transport order
        validateTransportOrder(transportOrder);

        // Save the validated transport order
        TransportOrderDAO.saveTransportOrder(transportOrder);
    }

    // Update existing transport order
    public void updateTransportOrder(TransportOrder transportOrder) {
        // Validate transport order
        validateTransportOrder(transportOrder);

        // Update the validated transport order
        TransportOrderDAO.updateTransportOrder(transportOrder);
    }

    public void completeTransportOrder(TransportOrder transportOrder) {
        // Validate transport order
        validateTransportOrder(transportOrder);

        if(transportOrder.getIsPaid() == false) {
            throw new IllegalArgumentException("Not paid transport orders cannot be completed");
        }
        // Increase the revenue of the company
        Company company = transportOrder.getCompany();
        company.setTotalRevenue(company.getTotalRevenue().add(transportOrder.getAmount()));
        CompanyDAO.updateCompany(company);
    }
    
    // Soft delete transport order (mark as deleted)
    public void deleteTransportOrder(TransportOrder transportOrder) {
        if (transportOrder == null || transportOrder.getId() == 0) {
            throw new IllegalArgumentException("Invalid transport order");
        }
        TransportOrderDAO.softDeleteTransportOrder(transportOrder);
    }

    // Hard delete transport order (mark as deleted)
    public void hardDeleteTransportOrder(TransportOrder transportOrder) {
        if (transportOrder == null || transportOrder.getId() == 0) {
            throw new IllegalArgumentException("Invalid transport order");
        }
        TransportOrderDAO.hardDeleteTransportOrder(transportOrder);
    }

    // Report exporting function
    public void exportFullReportToFile() {
        String fileName = "transport_orders_reports/" + UUID.randomUUID() + "-transport-order.txt";

        try (BufferedWriter writer = Files.newBufferedWriter(Paths.get(fileName))) {
            writer.write("Transport Report\n");
            writer.write("====================\n");
    
            // Total number of transport orders
            writer.write("Total number of completed transport orders:\n");
            writer.write(String.valueOf(getTotalTransportOrders()));
            writer.newLine();
            writer.newLine();
    
            // Total revenue
            writer.write("Total revenue from transport orders:\n");
            writer.write(getTotalTransportRevenue().toPlainString() + " (currency)");
            writer.newLine();
            writer.newLine();
    
            // Transport count by driver
            writer.write("Number of transports completed by each driver:\n");
            Map<String, Long> transportCountByDriver = getTransportCountByDriver();
            for (Map.Entry<String, Long> entry : transportCountByDriver.entrySet()) {
                writer.write(entry.getKey() + ": " + entry.getValue() + " transport(s)");
                writer.newLine();
            }
            writer.newLine();
    
            // Company revenue for a specific period
            LocalDate startDate = LocalDate.of(2024, 1, 1);
            LocalDate endDate = LocalDate.of(2024, 12, 31);
            writer.write("Company revenue for the period " + startDate + " to " + endDate + ":\n");
            writer.write(getCompanyRevenueForPeriod(startDate, endDate).toPlainString() + " (currency)");
            writer.newLine();
            writer.newLine();
    
            // Revenue by driver
            writer.write("Revenue generated by each driver:\n");
            Map<String, BigDecimal> revenueByDriver = getRevenueByDriver();
            for (Map.Entry<String, BigDecimal> entry : revenueByDriver.entrySet()) {
                writer.write(entry.getKey() + ": " + entry.getValue().toPlainString() + " (currency)");
                writer.newLine();
            }
    
            writer.write("====================\n");
            writer.write("End of Report\n");
        } catch (IOException e) {
            throw new RuntimeException("Failed to export report to file", e);
        }
    }

    // Save transport orders to external file
    public void saveTransportOrdersToFile(String filePath) {
        List<TransportOrder> transportOrders = getActiveTransportOrders();

        try (BufferedWriter writer = Files.newBufferedWriter(Paths.get(filePath))) {
            for (TransportOrder order : transportOrders) {
                writer.write(convertTransportOrderToCSV(order));
                writer.newLine();
            }
        } catch (IOException e) {
            throw new RuntimeException("Failed to save transport orders to file", e);
        }
    }

    // Load transport orders from external file
    public List<TransportOrder> loadTransportOrdersFromFile(String filePath) {
        List<TransportOrder> orders = new ArrayList<>();
        DriverService driverService = new DriverService();
        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
            String line;
            while ((line = reader.readLine()) != null) {
                String[] parts = line.split(",");
                TransportOrder order = new TransportOrder();
                order.setId(Long.parseLong(parts[0]));
                order.setCompany(CompanyDAO.getCompanyById(Long.parseLong(parts[1])));
                order.setVehicle(VehicleDAO.getVehicleById(Long.parseLong(parts[2])));
                order.setDriver(driverService.getDriverById(Long.parseLong(parts[3])));
                order.setDepartureLocation(parts[4]);
                order.setDestinationLocation(parts[5]);
                order.setDepartureDate(LocalDate.parse(parts[6]));
                order.setArrivalDate(LocalDate.parse(parts[7]));
                order.setDistance(Double.parseDouble(parts[8]));
                order.setTransportType(TransportType.valueOf(parts[9]));
                order.setCargoWeightKg(Integer.parseInt(parts[10]));
                order.setAmount(new BigDecimal(parts[11]));
                order.setIsPaid(Boolean.parseBoolean(parts[12]));
                orders.add(order);
            }
        } catch (IOException | NumberFormatException | DateTimeParseException e) {
            System.err.println("Error reading transport orders: " + e.getMessage());
        }
        return orders;
    }

    // Helper method for converting transport order in CSV row
    private String convertTransportOrderToCSV(TransportOrder order) {
        return String.join(",",
            String.valueOf(order.getId()),
            String.valueOf(order.getCompany().getId()),
            String.valueOf(order.getVehicle().getId()),
            String.valueOf(order.getDriver().getId()),
            order.getDepartureLocation(),
            order.getDestinationLocation(),
            order.getDepartureDate().toString(),
            order.getArrivalDate().toString(),
            String.valueOf(order.getDistance()),
            order.getTransportType().name(),
            String.valueOf(order.getCargoWeightKg()),
            order.getAmount().toPlainString(),
            String.valueOf(order.getIsPaid())
        );
    }    

    // Validate TransportOrder before saving or updating
    private void validateTransportOrder(TransportOrder transportOrder) {
        // Check if transport order is null
        if (transportOrder == null) {
            throw new IllegalArgumentException("Transport Order cannot be null");
        }

        // Validate company
        if (transportOrder.getCompany() == null) {
            throw new IllegalArgumentException("Company cannot be null");
        }

        // Validate vehicle
        if (transportOrder.getVehicle() == null) {
            throw new IllegalArgumentException("Vehicle cannot be null");
        }

        // Validate driver
        if (transportOrder.getDriver() == null) {
            throw new IllegalArgumentException("Driver cannot be null");
        }

        // Validate departure location
        if (transportOrder.getDepartureLocation() == null || transportOrder.getDepartureLocation().isEmpty()) {
            throw new IllegalArgumentException("Departure location cannot be blank");
        }
        if (transportOrder.getDepartureLocation().length() > 100) {
            throw new IllegalArgumentException("Departure location cannot exceed 100 characters");
        }

        // Validate destination location
        if (transportOrder.getDestinationLocation() == null || transportOrder.getDestinationLocation().isEmpty()) {
            throw new IllegalArgumentException("Destination location cannot be blank");
        }
        if (transportOrder.getDestinationLocation().length() > 100) {
            throw new IllegalArgumentException("Destination location cannot exceed 100 characters");
        }

        // Validate departure date
        if (transportOrder.getDepartureDate() == null) {
            throw new IllegalArgumentException("Departure date cannot be null");
        }

        // Validate arrival date
        if (transportOrder.getArrivalDate() == null) {
            throw new IllegalArgumentException("Arrival date cannot be null");
        }

        // Ensure that the arrival date is after the departure date
        if (transportOrder.getArrivalDate().isBefore(transportOrder.getDepartureDate())) {
            throw new IllegalArgumentException("Arrival date cannot be before departure date");
        }

        // Validate distance
        if (transportOrder.getDistance() == null || transportOrder.getDistance() < 0) {
            throw new IllegalArgumentException("Distance must be zero or positive");
        }

        // Validate transport type
        if (transportOrder.getTransportType() == null) {
            throw new IllegalArgumentException("Transport type cannot be null");
        }

        // Validate cargo weight
        if (transportOrder.getCargoWeightKg() == null || transportOrder.getCargoWeightKg() < 0) {
            throw new IllegalArgumentException("Cargo weight must be zero or positive");
        }

        // Validate amount
        if (transportOrder.getAmount() == null || transportOrder.getAmount().compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Amount must be greater than zero");
        }

        // Validate payment status
        if (transportOrder.getIsPaid() == null) {
            throw new IllegalArgumentException("Payment status cannot be null");
        }
    }
}